import logging
import typing as tp
from .consumer import QueueConsumer as QueueConsumer
from _typeshed import Incomplete

def get_global_log_properties(logger_name: Incomplete | None = ...): ...
def set_global_log_properties(**properties) -> None: ...
def reset_global_log_properties() -> None: ...
def clear_global_log_properties() -> None: ...
def set_callback_on_failure(callback: tp.Callable[[Exception], None]) -> None: ...

class StructuredLogRecord(logging.LogRecord):
    log_props: Incomplete
    def __init__(self, name, level, pathname, lineno, msg, args, exc_info, func: Incomplete | None = ..., sinfo: Incomplete | None = ..., log_props: Incomplete | None = ..., **kwargs) -> None: ...
    def getMessage(self): ...

class StructuredLogger(logging.Logger):
    def __init__(self, name, level=...) -> None: ...
    def makeRecord(self, name, level, fn, lno, msg, args, exc_info, func: Incomplete | None = ..., extra: Incomplete | None = ..., sinfo: Incomplete | None = ...): ...

class StructuredRootLogger(logging.RootLogger):
    def __init__(self, level=...) -> None: ...
    def makeRecord(self, name, level, fn, lno, msg, args, exc_info, func: Incomplete | None = ..., extra: Incomplete | None = ..., sinfo: Incomplete | None = ...): ...

class ConsoleStructuredLogHandler(logging.Handler):
    def __init__(self) -> None: ...
    def emit(self, record) -> None: ...

class SeqLogHandler(logging.Handler):
    server_url: Incomplete
    session: Incomplete
    json_encoder_class: Incomplete
    log_queue: Incomplete
    consumer: Incomplete
    def __init__(self, server_url, api_key: Incomplete | None = ..., batch_size: int = ..., auto_flush_timeout: Incomplete | None = ..., json_encoder_class: Incomplete | None = ...) -> None: ...
    def flush(self) -> None: ...
    def emit(self, record) -> None: ...
    def close(self) -> None: ...
    def publish_log_batch(self, batch: tp.Iterable[StructuredLogRecord]) -> None: ...
